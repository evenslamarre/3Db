<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Shape Stacker – Complete Shapes with Updated Pyramid</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #controls {
      width: 320px;
      padding: 10px;
      background: #f0f0f0;
      overflow-y: auto;
      box-sizing: border-box;
    }
    #canvasContainer {
      flex-grow: 1;
      background: #ddd;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    input, select, button {
      width: 100%;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
    label { font-weight: bold; }
    .shape-list { margin-top: 20px; }
    .shape-item {
      border-bottom: 1px solid #ccc;
      padding: 5px 0;
      font-size: 0.9em;
      position: relative;
    }
    .shape-controls {
      margin-top: 5px;
    }
    .shape-controls button {
      font-size: 0.8em;
      margin-right: 5px;
    }
    .delete-btn {
      position: absolute;
      right: 5px;
      top: 5px;
      color: red;
      cursor: pointer;
      font-weight: bold;
    }
    hr { margin: 10px 0; }
  </style>
</head>
<body>
<div id="controls">
  <h2>Add Shape</h2>
  <label for="shapeType">Shape Type:</label>
  <select id="shapeType">
    <option value="cone">Cone</option>
    <option value="cylinder">Cylinder</option>
    <option value="pyramid">Pyramid</option>
    <option value="prism">Prism</option>
    <option value="sphere">Sphere</option>
  </select>
  <div id="shapeParams">
    <!-- Parameter inputs inserted dynamically -->
  </div>
  <button id="addShapeBtn">Add Shape</button>
  <hr>
  <div>
    <label for="unit">Measurement Unit:</label>
    <input type="text" id="unit" value="u">
  </div>
  <div class="shape-list" id="shapeList">
    <h3>Stacked Shapes</h3>
    <!-- List of shapes with parameters and controls -->
  </div>
</div>
<div id="canvasContainer">
  <canvas id="canvas"></canvas>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const shapeTypeSelect = document.getElementById('shapeType');
    const shapeParamsDiv = document.getElementById('shapeParams');
    const addShapeBtn = document.getElementById('addShapeBtn');
    const shapeListDiv = document.getElementById('shapeList');
    const unitInput = document.getElementById('unit');

    let shapes = [];
    let editingIndex = -1;

    // --- Resize Canvas ---
    function resizeCanvas() {
      canvas.width = canvas.parentElement.clientWidth;
      canvas.height = canvas.parentElement.clientHeight;
      drawScene();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Global drawing settings.
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.lineWidth = 2;

    // --- Dynamic Parameter Panel ---
    function updateShapeParams() {
      const type = shapeTypeSelect.value;
      if (type === 'cone' || type === 'cylinder') {
        shapeParamsDiv.innerHTML = `
            <label for="param_radius">Radius:</label>
            <input type="number" step="any" id="param_radius" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      } else if (type === 'pyramid') {
        shapeParamsDiv.innerHTML = `
            <label for="param_baseType">Base Type:</label>
            <select id="param_baseType">
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="n-gon">N‑gon</option>
            </select>
            <div id="pyramidParams"></div>
          `;
        document.getElementById('param_baseType').addEventListener('change', updatePyramidParams);
        updatePyramidParams();
      } else if (type === 'prism') {
        shapeParamsDiv.innerHTML = `
            <label for="param_baseType">Base Type:</label>
            <select id="param_baseType">
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="n-gon">N‑gon</option>
              <option value="trapeze">Trapeze</option>
            </select>
            <div id="prismParams"></div>
          `;
        document.getElementById('param_baseType').addEventListener('change', updatePrismParams);
        updatePrismParams();
      } else if (type === 'sphere') {
        shapeParamsDiv.innerHTML = `
            <label for="param_radius">Radius:</label>
            <input type="number" step="any" id="param_radius" required>
          `;
      }
    }
    function updatePyramidParams() {
      const baseType = document.getElementById('param_baseType').value;
      const container = document.getElementById('pyramidParams');
      if (baseType === 'square' || baseType === 'triangle') {
        container.innerHTML = `
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      } else if (baseType === 'rectangle') {
        container.innerHTML = `
            <label for="param_width">Width:</label>
            <input type="number" step="any" id="param_width" required>
            <label for="param_depth">Depth:</label>
            <input type="number" step="any" id="param_depth" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      } else if (baseType === 'n-gon') {
        container.innerHTML = `
            <label for="param_n">Number of Sides (n):</label>
            <input type="number" step="1" id="param_n" required>
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      }
    }
    function updatePrismParams() {
      const baseType = document.getElementById('param_baseType').value;
      const container = document.getElementById('prismParams');
      if (baseType === 'square' || baseType === 'triangle') {
        container.innerHTML = `
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      } else if (baseType === 'rectangle') {
        container.innerHTML = `
            <label for="param_width">Width:</label>
            <input type="number" step="any" id="param_width" required>
            <label for="param_depth">Depth:</label>
            <input type="number" step="any" id="param_depth" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      } else if (baseType === 'n-gon') {
        container.innerHTML = `
            <label for="param_n">Number of Sides (n):</label>
            <input type="number" step="1" id="param_n" required>
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      } else if (baseType === 'trapeze') {
        container.innerHTML = `
            <label for="param_base1">Base 1 (top):</label>
            <input type="number" step="any" id="param_base1" required>
            <label for="param_base2">Base 2 (bottom):</label>
            <input type="number" step="any" id="param_base2" required>
            <label for="param_trapezeHeight">Trapeze Height:</label>
            <input type="number" step="any" id="param_trapezeHeight" required>
            <label for="param_height">Prism Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
      }
    }
    shapeTypeSelect.addEventListener('change', updateShapeParams);
    updateShapeParams();

    // --- Add or Update Shape ---
    addShapeBtn.addEventListener('click', addOrUpdateShape);
    function addOrUpdateShape() {
      const type = shapeTypeSelect.value;
      const unit = unitInput.value || "u";
      let params = {};
      if (type === 'cone' || type === 'cylinder') {
        params.radius = document.getElementById('param_radius').value;
        params.height = document.getElementById('param_height').value;
      } else if (type === 'pyramid') {
        params.baseType = document.getElementById('param_baseType').value;
        if (params.baseType === 'square' || params.baseType === 'triangle') {
          params.side = document.getElementById('param_side').value;
          params.height = document.getElementById('param_height').value;
        } else if (params.baseType === 'rectangle') {
          params.width = document.getElementById('param_width').value;
          params.depth = document.getElementById('param_depth').value;
          params.height = document.getElementById('param_height').value;
        } else if (params.baseType === 'n-gon') {
          params.n = document.getElementById('param_n').value;
          params.side = document.getElementById('param_side').value;
          params.height = document.getElementById('param_height').value;
        }
      } else if (type === 'prism') {
        params.baseType = document.getElementById('param_baseType').value;
        if (params.baseType === 'square' || params.baseType === 'triangle') {
          params.side = document.getElementById('param_side').value;
          params.height = document.getElementById('param_height').value;
        } else if (params.baseType === 'rectangle') {
          params.width = document.getElementById('param_width').value;
          params.depth = document.getElementById('param_depth').value;
          params.height = document.getElementById('param_height').value;
        } else if (params.baseType === 'n-gon') {
          params.n = document.getElementById('param_n').value;
          params.side = document.getElementById('param_side').value;
          params.height = document.getElementById('param_height').value;
        } else if (params.baseType === 'trapeze') {
          params.base1 = document.getElementById('param_base1').value;
          params.base2 = document.getElementById('param_base2').value;
          params.trapezeHeight = document.getElementById('param_trapezeHeight').value;
          params.height = document.getElementById('param_height').value;
        }
      } else if (type === 'sphere') {
        params.radius = document.getElementById('param_radius').value;
        params.height = 2 * parseFloat(params.radius);
      }
      if (editingIndex === -1) {
        shapes.push({ type, params, unit });
        computeShapeProperties(shapes[shapes.length - 1]);
      } else {
        shapes[editingIndex] = { type, params, unit };
        computeShapeProperties(shapes[editingIndex]);
        editingIndex = -1;
        addShapeBtn.textContent = "Add Shape";
      }
      updateStackElevations();
      updateShapeList();
      drawScene();
    }

    // --- Delete, Move, and Edit Controls ---
    window.deleteShape = function(index) {
      shapes.splice(index, 1);
      updateStackElevations();
      updateShapeList();
      drawScene();
    };
    window.moveShape = function(index, direction) {
      if (direction === 'up' && index < shapes.length - 1) {
        [shapes[index], shapes[index + 1]] = [shapes[index + 1], shapes[index]];
      } else if (direction === 'down' && index > 0) {
        [shapes[index], shapes[index - 1]] = [shapes[index - 1], shapes[index]];
      }
      updateStackElevations();
      updateShapeList();
      drawScene();
    };
    window.editShape = function(index) {
      const shape = shapes[index];
      shapeTypeSelect.value = shape.type;
      updateShapeParams();
      if (shape.type === 'cone' || shape.type === 'cylinder') {
        document.getElementById('param_radius').value = shape.params.radius;
        document.getElementById('param_height').value = shape.params.height;
      } else if (shape.type === 'pyramid') {
        document.getElementById('param_baseType').value = shape.params.baseType;
        updatePyramidParams();
        if (shape.params.baseType === 'square' || shape.params.baseType === 'triangle') {
          document.getElementById('param_side').value = shape.params.side;
          document.getElementById('param_height').value = shape.params.height;
        } else if (shape.params.baseType === 'rectangle') {
          document.getElementById('param_width').value = shape.params.width;
          document.getElementById('param_depth').value = shape.params.depth;
          document.getElementById('param_height').value = shape.params.height;
        } else if (shape.params.baseType === 'n-gon') {
          document.getElementById('param_n').value = shape.params.n;
          document.getElementById('param_side').value = shape.params.side;
          document.getElementById('param_height').value = shape.params.height;
        }
      } else if (shape.type === 'prism') {
        document.getElementById('param_baseType').value = shape.params.baseType;
        updatePrismParams();
        if (shape.params.baseType === 'square' || shape.params.baseType === 'triangle') {
          document.getElementById('param_side').value = shape.params.side;
          document.getElementById('param_height').value = shape.params.height;
        } else if (shape.params.baseType === 'rectangle') {
          document.getElementById('param_width').value = shape.params.width;
          document.getElementById('param_depth').value = shape.params.depth;
          document.getElementById('param_height').value = shape.params.height;
        } else if (shape.params.baseType === 'n-gon') {
          document.getElementById('param_n').value = shape.params.n;
          document.getElementById('param_side').value = shape.params.side;
          document.getElementById('param_height').value = shape.params.height;
        } else if (shape.params.baseType === 'trapeze') {
          document.getElementById('param_base1').value = shape.params.base1;
          document.getElementById('param_base2').value = shape.params.base2;
          document.getElementById('param_trapezeHeight').value = shape.params.trapezeHeight;
          document.getElementById('param_height').value = shape.params.height;
        }
      } else if (shape.type === 'sphere') {
        document.getElementById('param_radius').value = shape.params.radius;
      }
      unitInput.value = shape.unit;
      addShapeBtn.textContent = "Update Shape";
      editingIndex = index;
    };

    // --- Update Stacking Elevations ---
    function updateStackElevations() {
      let currentElevation = 0;
      shapes.forEach(shape => {
        shape.bottom = currentElevation;
        let h = parseFloat(shape.params.height);
        shape.top = shape.bottom + h;
        currentElevation = shape.top;
      });
    }

    // --- Compute Shape Properties ---
    function computeShapeProperties(shape) {
      let computed = {};
      if (shape.type === 'cone') {
        const r = parseFloat(shape.params.radius);
        const h = parseFloat(shape.params.height);
        const s = Math.sqrt(r * r + h * h);
        computed.lateralArea = Math.PI * r * s;
        computed.totalArea = Math.PI * r * (r + s);
        computed.volume = (1/3) * Math.PI * r * r * h;
      } else if (shape.type === 'cylinder') {
        const r = parseFloat(shape.params.radius);
        const h = parseFloat(shape.params.height);
        computed.lateralArea = 2 * Math.PI * r * h;
        computed.totalArea = 2 * Math.PI * r * (r + h);
        computed.volume = Math.PI * r * r * h;
      } else if (shape.type === 'pyramid') {
        const baseType = shape.params.baseType;
        const h = parseFloat(shape.params.height);
        if (baseType === 'square') {
          const a = parseFloat(shape.params.side);
          const baseArea = a * a;
          const s = Math.sqrt((a/2)**2 + h * h);
          computed.lateralArea = 2 * a * s;
          computed.totalArea = baseArea + computed.lateralArea;
          computed.volume = (1/3) * baseArea * h;
        } else if (baseType === 'rectangle') {
          const w = parseFloat(shape.params.width);
          const d = parseFloat(shape.params.depth);
          const baseArea = w * d;
          const s1 = Math.sqrt((d/2)**2 + h * h);
          const s2 = Math.sqrt((w/2)**2 + h * h);
          computed.lateralArea = w * s1 + d * s2;
          computed.totalArea = baseArea + computed.lateralArea;
          computed.volume = (1/3) * baseArea * h;
        } else if (baseType === 'triangle') {
          const a = parseFloat(shape.params.side);
          const baseArea = (Math.sqrt(3)/4) * a * a;
          const s = Math.sqrt(h * h + (a/Math.sqrt(3))**2);
          computed.lateralArea = (3 * a * s) / 2;
          computed.totalArea = baseArea + computed.lateralArea;
          computed.volume = (1/3) * baseArea * h;
        } else if (baseType === 'n-gon') {
          const n = parseInt(shape.params.n);
          const a = parseFloat(shape.params.side);
          const baseArea = (n * a * a) / (4 * Math.tan(Math.PI/n));
          const R = a / (2 * Math.sin(Math.PI/n));
          const s = Math.sqrt(h * h + R * R);
          computed.lateralArea = 0.5 * n * a * s;
          computed.totalArea = baseArea + computed.lateralArea;
          computed.volume = (1/3) * baseArea * h;
        }
      } else if (shape.type === 'prism') {
        const baseType = shape.params.baseType;
        const h = parseFloat(shape.params.height);
        if (baseType === 'square') {
          const a = parseFloat(shape.params.side);
          const baseArea = a * a;
          computed.lateralArea = 4 * a * h;
          computed.totalArea = 2 * baseArea + computed.lateralArea;
          computed.volume = baseArea * h;
        } else if (baseType === 'rectangle') {
          const w = parseFloat(shape.params.width);
          const d = parseFloat(shape.params.depth);
          const baseArea = w * d;
          computed.lateralArea = 2 * (w + d) * h;
          computed.totalArea = 2 * baseArea + computed.lateralArea;
          computed.volume = baseArea * h;
        } else if (baseType === 'triangle') {
          const a = parseFloat(shape.params.side);
          const baseArea = (Math.sqrt(3)/4) * a * a;
          computed.lateralArea = 3 * a * h;
          computed.totalArea = 2 * baseArea + computed.lateralArea;
          computed.volume = baseArea * h;
        } else if (baseType === 'n-gon') {
          const n = parseInt(shape.params.n);
          const a = parseFloat(shape.params.side);
          const baseArea = (n * a * a) / (4 * Math.tan(Math.PI/n));
          computed.lateralArea = n * a * h;
          computed.totalArea = 2 * baseArea + computed.lateralArea;
          computed.volume = baseArea * h;
        } else if (baseType === 'trapeze') {
          const b1 = parseFloat(shape.params.base1);
          const b2 = parseFloat(shape.params.base2);
          const tH = parseFloat(shape.params.trapezeHeight);
          const baseArea = ((b1 + b2) / 2) * tH;
          const side = Math.sqrt(((b2 - b1) / 2)**2 + tH * tH);
          computed.lateralArea = (b1 + b2 + 2 * side) * h;
          computed.totalArea = 2 * baseArea + computed.lateralArea;
          computed.volume = baseArea * h;
        }
      } else if (shape.type === 'sphere') {
        const r = parseFloat(shape.params.radius);
        computed.totalArea = 4 * Math.PI * r * r;
        computed.lateralArea = computed.totalArea;
        computed.volume = (4/3) * Math.PI * r * r * r;
      }
      shape.computed = computed;
    }

    // --- Helper: 2D Cross Product (for convex hull) ---
    function cross(o, a, b) {
      return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
    }

    // --- Compute Convex Hull (Andrew's Monotone Chain) ---
    function computeConvexHull(points) {
      let pts = points.slice();
      pts.sort((a, b) => {
        if (a.proj.x === b.proj.x) return a.proj.y - b.proj.y;
        return a.proj.x - b.proj.x;
      });
      const lower = [];
      for (let p of pts) {
        while (lower.length >= 2 && cross(lower[lower.length - 2].proj, lower[lower.length - 1].proj, p.proj) <= 0) {
          lower.pop();
        }
        lower.push(p);
      }
      const upper = [];
      for (let i = pts.length - 1; i >= 0; i--) {
        let p = pts[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2].proj, upper[upper.length - 1].proj, p.proj) <= 0) {
          upper.pop();
        }
        upper.push(p);
      }
      lower.pop();
      upper.pop();
      return lower.concat(upper);
    }
//pasted code to fix prisms:
    // Helper: Compute the midpoint between two points (assumes same y)
    function computeMidpoint(pt1, pt2) {
      return {
        x: (pt1.x + pt2.x) / 2,
        y: pt1.y,
        z: (pt1.z + pt2.z) / 2
      };
    }

// Helper: Draw a polygon in dotted lines given an array of points
    function drawPolygonDotted(points, origin, scale) {
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      for (let i = 0; i < points.length; i++) {
        let p = project(points[i].x, points[i].y, points[i].z);
        let X = origin.x + p.x * scale;
        let Y = origin.y + p.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }

// Updated drawPrism() function
    function drawPrism(shape, ctx, origin, scale) {
      const bottomY = shape.bottom;
      const topY = shape.top;
      const baseType = shape.params.baseType;
      let bottomPoints = [];

      // Compute the base vertices based on the selected base type.
      if (baseType === 'square') {
        const a = parseFloat(shape.params.side);
        bottomPoints = [
          { x: -a/2, y: bottomY, z: -a/2 },
          { x: a/2, y: bottomY, z: -a/2 },
          { x: a/2, y: bottomY, z: a/2 },
          { x: -a/2, y: bottomY, z: a/2 }
        ];
      } else if (baseType === 'rectangle') {
        const w = parseFloat(shape.params.width);
        const d = parseFloat(shape.params.depth);
        bottomPoints = [
          { x: -w/2, y: bottomY, z: -d/2 },
          { x: w/2, y: bottomY, z: -d/2 },
          { x: w/2, y: bottomY, z: d/2 },
          { x: -w/2, y: bottomY, z: d/2 }
        ];
      } else if (baseType === 'triangle') {
        const a = parseFloat(shape.params.side);
        for (let i = 0; i < 3; i++) {
          let angle = -Math.PI/2 + i * (2*Math.PI/3);
          bottomPoints.push({ x: a * Math.cos(angle), y: bottomY, z: a * Math.sin(angle) });
        }
      } else if (baseType === 'n-gon') {
        const n = parseInt(shape.params.n);
        const a = parseFloat(shape.params.side);
        const R = a / (2 * Math.sin(Math.PI/n));
        for (let i = 0; i < n; i++) {
          let angle = -Math.PI/2 + i * (2*Math.PI/n);
          bottomPoints.push({ x: R * Math.cos(angle), y: bottomY, z: R * Math.sin(angle) });
        }
      } else if (baseType === 'trapeze') {
        const b1 = parseFloat(shape.params.base1);
        const b2 = parseFloat(shape.params.base2);
        const tH = parseFloat(shape.params.trapezeHeight);
        bottomPoints = [
          { x: -b2/2, y: bottomY, z: -tH/2 },
          { x: b2/2, y: bottomY, z: -tH/2 },
          { x: b1/2, y: bottomY, z: tH/2 },
          { x: -b1/2, y: bottomY, z: tH/2 }
        ];
      }

      // Draw the bottom base outline as a dotted polygon.
      drawPolygonDotted(bottomPoints, origin, scale);

      // For an n-gon, draw the base apothem dimension (from the base center to the midpoint of the first edge).
      if (baseType === 'n-gon') {
        const baseCenter = { x: 0, y: bottomY, z: 0 };  // Assuming the base is centered at (0, bottomY, 0)
        const midEdge = computeMidpoint(bottomPoints[0], bottomPoints[1]);
        const baseApothem = Math.sqrt(midEdge.x * midEdge.x + midEdge.z * midEdge.z);
        drawDimensionLine(ctx, origin, scale, baseCenter, midEdge, "a: " + baseApothem.toFixed(2) + " " + shape.unit);
      }

      // Draw the vertical (height) dimension from the base center to the top base center.
      const bottomCenter = { x: 0, y: bottomY, z: 0 };
      const topCenter = { x: 0, y: topY, z: 0 };
      drawDimensionLine(ctx, origin, scale, bottomCenter, topCenter, "h: " + Math.abs(topY - bottomY).toFixed(2) + " " + shape.unit);

      // For additional information, label one of the base's side lengths.
      // We'll choose the "left" edge: the edge whose midpoint has the smallest x value.
      let leftEdge = null;
      bottomPoints.forEach((pt, i) => {
        let next = bottomPoints[(i + 1) % bottomPoints.length];
        let mid = computeMidpoint(pt, next);
        if (!leftEdge || mid.x < leftEdge.mid.x) {
          leftEdge = { mid: mid, pt1: pt, pt2: next };
        }
      });
      const sideLength = Math.sqrt((leftEdge.pt1.x - leftEdge.pt2.x)**2 + (leftEdge.pt1.z - leftEdge.pt2.z)**2);
      drawDimensionLine(ctx, origin, scale, leftEdge.pt1, leftEdge.pt2, "s: " + sideLength.toFixed(2) + " " + shape.unit);
    }



// end of pasted code
    // --- Draw Full Base Ellipse in Dotted Lines ---
    // This function draws the complete base circle (projected as an ellipse) in dotted style.
    function drawFullBaseEllipseDotted(r, yBase, origin, scale) {
      const N = 100;
      let pts = [];
      for (let i = 0; i <= N; i++) {
        let t = 2 * Math.PI * i / N;
        let x = r * Math.cos(t);
        let z = r * Math.sin(t);
        let p = project(x, yBase, z);
        pts.push(p);
      }
      ctx.setLineDash([10,10]);
      ctx.beginPath();
      pts.forEach((pt, i) => {
        let X = origin.x + pt.x * scale;
        let Y = origin.y + pt.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      });
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }
    function drawCone(shape, ctx, origin, scale) {
      const r = parseFloat(shape.params.radius);
      const bottomY = shape.bottom;
      const topY = shape.top;
      const apex = { x: 0, y: topY, z: 0 };
      const N_u = 20, N_t = 100;
      let samplePoints = [];
      for (let i = 0; i < N_u; i++) {
        let u = i / (N_u - 1);
        for (let j = 0; j < N_t; j++) {
          let t = (2 * Math.PI * j) / N_t;
          let x = (1 - u) * apex.x + u * (r * Math.cos(t));
          let y = (1 - u) * apex.y + u * bottomY;
          let z = (1 - u) * apex.z + u * (r * Math.sin(t));
          samplePoints.push({ world: { x, y, z }, proj: project(x, y, z) });
        }
      }
      // Draw the lateral silhouette with a thicker solid line.
      ctx.save();
      ctx.lineWidth = 3;
      const hull = computeConvexHull(samplePoints);
      ctx.beginPath();
      for (let i = 0; i < hull.length; i++) {
        let pt = hull[i];
        let X = origin.x + pt.proj.x * scale;
        let Y = origin.y + pt.proj.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
      // Overlay the full base ellipse in dotted lines.
      drawFullBaseEllipseDotted(r, bottomY, origin, scale);
      // Draw apex as a small red circle.
      let pA = project(apex.x, apex.y, apex.z);
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(origin.x + pA.x * scale, origin.y + pA.y * scale, 3, 0, 2 * Math.PI);
      ctx.fill();
      // Draw dimension lines.
      drawDimensionLine(ctx, origin, scale,
        { x: 0, y: bottomY, z: 0 },
        { x: r, y: bottomY, z: 0 },
        r.toFixed(2) + " " + shape.unit);
      drawDimensionLine(ctx, origin, scale,
        { x: 0, y: bottomY, z: 0 },
        { x: 0, y: topY, z: 0 },
        Math.abs(topY - bottomY).toFixed(2) + " " + shape.unit);
      const s = Math.sqrt(r * r + (topY - bottomY) ** 2);
      drawDimensionLine(ctx, origin, scale,
        { x: r, y: bottomY, z: 0 },
        { x: 0, y: topY, z: 0 },
        s.toFixed(2) + " " + shape.unit);
    }

    // --- Draw Cylinder ---
    // (Cylinder code remains unchanged.)
    function drawCylinder(shape, ctx, origin, scale) {
      const r = parseFloat(shape.params.radius);
      const bottomY = shape.bottom;
      const topY = shape.top;
      let samplePoints = [];
      for (let i = 0; i < 100; i++) {
        let theta = (2 * Math.PI * i) / 100;
        samplePoints.push({
          world: { x: r * Math.cos(theta), y: bottomY, z: r * Math.sin(theta) },
          proj: project(r * Math.cos(theta), bottomY, r * Math.sin(theta))
        });
      }
      for (let i = 0; i < 100; i++) {
        let theta = (2 * Math.PI * i) / 100;
        samplePoints.push({
          world: { x: r * Math.cos(theta), y: topY, z: r * Math.sin(theta) },
          proj: project(r * Math.cos(theta), topY, r * Math.sin(theta))
        });
      }
      drawSilhouette(samplePoints, ctx, origin, scale);
      // Draw top base ellipse solid.
      const N = 100;
      ctx.beginPath();
      for (let i = 0; i <= N; i++) {
        let t = 2 * Math.PI * i / N;
        let x = r * Math.cos(t);
        let z = r * Math.sin(t);
        let p = project(x, topY, z);
        let X = origin.x + p.x * scale;
        let Y = origin.y + p.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();
      // Draw bottom base ellipse dotted.
      drawFullBaseEllipseDotted(r, bottomY, origin, scale);
      // Dimension lines.
      drawDimensionLine(ctx, origin, scale,
        { x: 0, y: bottomY, z: 0 },
        { x: r, y: bottomY, z: 0 },
        r.toFixed(2) + " " + shape.unit);
      drawDimensionLine(ctx, origin, scale,
        { x: 0, y: bottomY, z: 0 },
        { x: 0, y: topY, z: 0 },
        Math.abs(topY - bottomY).toFixed(2) + " " + shape.unit);
    }

    // --- Draw Silhouette (convex hull) ---
    function drawSilhouette(samplePoints, ctx, origin, scale) {
      const hull = computeConvexHull(samplePoints);
      ctx.beginPath();
      for (let i = 0; i < hull.length; i++) {
        let pt = hull[i];
        let X = origin.x + pt.proj.x * scale;
        let Y = origin.y + pt.proj.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // --- Isometric Projection ---
    function project(x, y, z) {
      const angle = Math.PI / 6; // 30°
      const isoX = (x - z) * Math.cos(angle);
      const isoY = y + (x + z) * Math.sin(angle);
      return { x: isoX, y: -isoY };
    }

    // --- Draw Dimension Line ---
    function drawDimensionLine(ctx, origin, scale, point1, point2, text) {
      const p1 = project(point1.x, point1.y, point1.z);
      const p2 = project(point2.x, point2.y, point2.z);
      const x1 = origin.x + p1.x * scale;
      const y1 = origin.y + p1.y * scale;
      const x2 = origin.x + p2.x * scale;
      const y2 = origin.y + p2.y * scale;
      ctx.save();
      ctx.lineWidth = 2;
      ctx.setLineDash([10,10]);
      ctx.strokeStyle = 'blue';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'blue';
      ctx.font = "12px sans-serif";
      const midX = (x1 + x2) / 2;
      const midY = (y1 + y2) / 2;
      ctx.fillText(text, midX + 5, midY - 5);
      ctx.restore();
    }

    // --- Helper: Draw Polygon in Dotted Lines ---
    function drawPolygonDotted(points, origin, scale) {
      ctx.setLineDash([10,10]);
      ctx.beginPath();
      for (let i = 0; i < points.length; i++) {
        let p = project(points[i].x, points[i].y, points[i].z);
        let X = origin.x + p.x * scale;
        let Y = origin.y + p.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // --- Helper: Compute Midpoint Between Two Points ---
    function computeMidpoint(pt1, pt2) {
      return { x: (pt1.x + pt2.x) / 2, y: pt1.y, z: (pt1.z + pt2.z) / 2 };
    }

    // --- Draw Pyramid ---
    // This routine draws:
    // 1. The base polygon in dotted lines.
    // 2. If the base is an n‑gon, a dimension line for the base apothem (from the base center to the midpoint of the first edge).
    // 3. The lateral (slant) height from the midpoint of the "front" edge (the one whose midpoint has the smallest world‑space z) to the apex.
    // 4. The length of one of the base’s sides (the "left" edge, whose midpoint has the smallest x).
    // 5. The vertical height from the base center to the apex.
    function drawPyramid(shape, ctx, origin, scale) {
      const bottomY = shape.bottom;
      const topY = shape.top;
      const baseType = shape.params.baseType;
      let basePoints = [];

      if (baseType === 'square') {
        const a = parseFloat(shape.params.side);
        basePoints = [
          { x: -a/2, y: bottomY, z: -a/2 },
          { x: a/2, y: bottomY, z: -a/2 },
          { x: a/2, y: bottomY, z: a/2 },
          { x: -a/2, y: bottomY, z: a/2 }
        ];
      } else if (baseType === 'rectangle') {
        const w = parseFloat(shape.params.width);
        const d = parseFloat(shape.params.depth);
        basePoints = [
          { x: -w/2, y: bottomY, z: -d/2 },
          { x: w/2, y: bottomY, z: -d/2 },
          { x: w/2, y: bottomY, z: d/2 },
          { x: -w/2, y: bottomY, z: d/2 }
        ];
      } else if (baseType === 'triangle') {
        const a = parseFloat(shape.params.side);
        for (let i = 0; i < 3; i++) {
          let angle = -Math.PI/2 + i * (2 * Math.PI / 3);
          basePoints.push({ x: a * Math.cos(angle), y: bottomY, z: a * Math.sin(angle) });
        }
      } else if (baseType === 'n-gon') {
        const n = parseInt(shape.params.n);
        const a = parseFloat(shape.params.side);
        const R = a / (2 * Math.sin(Math.PI / n));
        for (let i = 0; i < n; i++) {
          let angle = -Math.PI/2 + i * (2 * Math.PI / n);
          basePoints.push({ x: R * Math.cos(angle), y: bottomY, z: R * Math.sin(angle) });
        }
      }

      // Draw lateral silhouette (base outline + apex)
      let samplePoints = [];
      basePoints.forEach(pt => {
        samplePoints.push({ world: pt, proj: project(pt.x, pt.y, pt.z) });
      });
      samplePoints.push({ world: { x: 0, y: topY, z: 0 }, proj: project(0, topY, 0) });
      drawSilhouette(samplePoints, ctx, origin, scale);

      // Draw full base outline as dotted polygon.
      drawPolygonDotted(basePoints, origin, scale);

      // Base center is assumed at (0, bottomY, 0) for a centered, regular polygon.
      const baseCenter = { x: 0, y: bottomY, z: 0 };

      // If the base is an n‑gon, draw the base apothem (from center to midpoint of first edge).
      if (baseType === 'n-gon') {
        const midEdge = computeMidpoint(basePoints[0], basePoints[1]);
        const baseApothem = Math.sqrt(midEdge.x * midEdge.x + midEdge.z * midEdge.z);
        drawDimensionLine(ctx, origin, scale, baseCenter, midEdge, "a: " + baseApothem.toFixed(2) + " " + shape.unit);
      }

      // Determine the "front" edge: the edge whose midpoint has the smallest world z (i.e. most toward the viewer).
      let frontEdge = null;
      basePoints.forEach((pt, i) => {
        const next = basePoints[(i + 1) % basePoints.length];
        const mid = computeMidpoint(pt, next);
        if (!frontEdge || mid.z < frontEdge.mid.z) {
          frontEdge = { mid: mid, pt1: pt, pt2: next };
        }
      });
      // Slant height is the distance from the midpoint of the front edge to the apex.
      const horizontal = Math.sqrt(frontEdge.mid.x * frontEdge.mid.x + frontEdge.mid.z * frontEdge.mid.z);
      const slant = Math.sqrt(horizontal * horizontal + (topY - bottomY) ** 2);
      drawDimensionLine(ctx, origin, scale, frontEdge.mid, { x: 0, y: topY, z: 0 }, "l: " + slant.toFixed(2) + " " + shape.unit);

      // Determine the "left" edge: the edge whose midpoint has the smallest world x (most negative).
      let leftEdge = null;
      basePoints.forEach((pt, i) => {
        const next = basePoints[(i + 1) % basePoints.length];
        const mid = computeMidpoint(pt, next);
        if (!leftEdge || mid.x < leftEdge.mid.x) {
          leftEdge = { mid: mid, pt1: pt, pt2: next };
        }
      });
      const sideLength = Math.sqrt((leftEdge.pt1.x - leftEdge.pt2.x) ** 2 + (leftEdge.pt1.z - leftEdge.pt2.z) ** 2);
      drawDimensionLine(ctx, origin, scale, leftEdge.pt1, leftEdge.pt2, "s: " + sideLength.toFixed(2) + " " + shape.unit);

      // Vertical dimension from base center to apex.
      drawDimensionLine(ctx, origin, scale, baseCenter, { x: 0, y: topY, z: 0 }, Math.abs(topY - bottomY).toFixed(2) + " " + shape.unit);
    }
//pasted code prims
    // Helper: Compute the midpoint between two points (assumes same y)
    function computeMidpoint(pt1, pt2) {
      return {
        x: (pt1.x + pt2.x) / 2,
        y: pt1.y,
        z: (pt1.z + pt2.z) / 2
      };
    }

// Helper: Draw a polygon in dotted lines given an array of points
    function drawPolygonDotted(points, origin, scale) {
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      for (let i = 0; i < points.length; i++) {
        let p = project(points[i].x, points[i].y, points[i].z);
        let X = origin.x + p.x * scale;
        let Y = origin.y + p.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }

// Updated drawPrism() function
    // Helper: Compute the midpoint between two points (assumes same y)
    function computeMidpoint(pt1, pt2) {
      return {
        x: (pt1.x + pt2.x) / 2,
        y: pt1.y,
        z: (pt1.z + pt2.z) / 2
      };
    }

// Helper: Draw a polygon in dotted lines given an array of points.
    function drawPolygonDotted(points, origin, scale) {
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      for (let i = 0; i < points.length; i++) {
        let p = project(points[i].x, points[i].y, points[i].z);
        let X = origin.x + p.x * scale;
        let Y = origin.y + p.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
    }

// Updated drawPrism() function:
    function drawPrism(shape, ctx, origin, scale) {
      const bottomY = shape.bottom;
      const topY = shape.top;
      const baseType = shape.params.baseType;
      let bottomPoints = [];

      // Compute the base vertices based on the selected base type.
      if (baseType === 'square') {
        const a = parseFloat(shape.params.side);
        bottomPoints = [
          { x: -a/2, y: bottomY, z: -a/2 },
          { x: a/2, y: bottomY, z: -a/2 },
          { x: a/2, y: bottomY, z: a/2 },
          { x: -a/2, y: bottomY, z: a/2 }
        ];
      } else if (baseType === 'rectangle') {
        const w = parseFloat(shape.params.width);
        const d = parseFloat(shape.params.depth);
        bottomPoints = [
          { x: -w/2, y: bottomY, z: -d/2 },
          { x: w/2, y: bottomY, z: -d/2 },
          { x: w/2, y: bottomY, z: d/2 },
          { x: -w/2, y: bottomY, z: d/2 }
        ];
      } else if (baseType === 'triangle') {
        const a = parseFloat(shape.params.side);
        for (let i = 0; i < 3; i++) {
          let angle = -Math.PI/2 + i * (2 * Math.PI / 3);
          bottomPoints.push({ x: a * Math.cos(angle), y: bottomY, z: a * Math.sin(angle) });
        }
      } else if (baseType === 'n-gon') {
        const n = parseInt(shape.params.n);
        const a = parseFloat(shape.params.side);
        const R = a / (2 * Math.sin(Math.PI / n));
        for (let i = 0; i < n; i++) {
          let angle = -Math.PI/2 + i * (2 * Math.PI / n);
          bottomPoints.push({ x: R * Math.cos(angle), y: bottomY, z: R * Math.sin(angle) });
        }
      } else if (baseType === 'trapeze') {
        const b1 = parseFloat(shape.params.base1);
        const b2 = parseFloat(shape.params.base2);
        const tH = parseFloat(shape.params.trapezeHeight);
        bottomPoints = [
          { x: -b2/2, y: bottomY, z: -tH/2 },
          { x: b2/2, y: bottomY, z: -tH/2 },
          { x: b1/2, y: bottomY, z: tH/2 },
          { x: -b1/2, y: bottomY, z: tH/2 }
        ];
      }

      // Draw the bottom base outline as a dotted polygon.
      drawPolygonDotted(bottomPoints, origin, scale);

      // If the base is an n-gon, draw the base apothem dimension.
      if (baseType === 'n-gon') {
        const baseCenter = { x: 0, y: bottomY, z: 0 }; // Assumed center
        const midEdge = computeMidpoint(bottomPoints[0], bottomPoints[1]);
        const baseApothem = Math.sqrt(midEdge.x * midEdge.x + midEdge.z * midEdge.z);
        drawDimensionLine(ctx, origin, scale, baseCenter, midEdge, "a: " + baseApothem.toFixed(2) + " " + shape.unit);
      }

      // Draw the vertical (height) dimension from the bottom center to the top center.
      const bottomCenter = { x: 0, y: bottomY, z: 0 };
      const topCenter = { x: 0, y: topY, z: 0 };
      drawDimensionLine(ctx, origin, scale, bottomCenter, topCenter, "h: " + Math.abs(topY - bottomY).toFixed(2) + " " + shape.unit);

      // Determine the "left" edge: the edge whose midpoint has the smallest x.
      let leftEdge = null;
      bottomPoints.forEach((pt, i) => {
        let next = bottomPoints[(i + 1) % bottomPoints.length];
        let mid = computeMidpoint(pt, next);
        if (!leftEdge || mid.x < leftEdge.mid.x) {
          leftEdge = { mid: mid, pt1: pt, pt2: next };
        }
      });
      const sideLength = Math.sqrt((leftEdge.pt1.x - leftEdge.pt2.x) ** 2 + (leftEdge.pt1.z - leftEdge.pt2.z) ** 2);
      drawDimensionLine(ctx, origin, scale, leftEdge.pt1, leftEdge.pt2, "s: " + sideLength.toFixed(2) + " " + shape.unit);

      // *** NEW: Draw the top face outline as a solid polygon ***
      const topPoints = bottomPoints.map(pt => ({ x: pt.x, y: topY, z: pt.z }));
      ctx.beginPath();
      for (let i = 0; i < topPoints.length; i++) {
        let p = project(topPoints[i].x, topPoints[i].y, topPoints[i].z);
        let X = origin.x + p.x * scale;
        let Y = origin.y + p.y * scale;
        if (i === 0) ctx.moveTo(X, Y);
        else ctx.lineTo(X, Y);
      }
      ctx.closePath();
      ctx.stroke();

      // Finally, to capture the overall prism silhouette (sides) you can optionally combine bottom and top points:
      let samplePoints = [];
      bottomPoints.forEach(pt => {
        samplePoints.push({ world: pt, proj: project(pt.x, pt.y, pt.z) });
      });
      topPoints.forEach(pt => {
        samplePoints.push({ world: pt, proj: project(pt.x, pt.y, pt.z) });
      });
      drawSilhouette(samplePoints, ctx, origin, scale);
    }


    function drawSphere(shape, ctx, origin, scale) {
      const r = parseFloat(shape.params.radius);
      const bottomY = shape.bottom;
      const topY = shape.top;
      // Compute the sphere's center in world coordinates.
      const centerY = bottomY + r;
      const centerP = project(0, centerY, 0);
      const cx = origin.x + centerP.x * scale;
      const cy = origin.y + centerP.y * scale;

      ctx.lineWidth = 2;

      // Draw the outer sphere outline (solid circle).
      ctx.beginPath();
      ctx.arc(cx, cy, r * scale, 0, 2 * Math.PI);
      ctx.stroke();

      // Draw the "equator" (middle ellipse) as dotted.
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.ellipse(cx, cy, r * scale, r * scale * 0.5, 0, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw the dimension line for the sphere's radius.
      // Instead of using (r, centerY, 0), compute the point on the ellipse's rightmost edge.
      // Solve for (X, centerY, Z) such that:
      //   (X - Z)*cos30 = r  and  X + Z = 0.
      // This yields X = r/(2*cos30) = r/√3 and Z = -r/√3.
      const endpoint = { x: r/Math.sqrt(3), y: centerY, z: -r/Math.sqrt(3) };
      drawDimensionLine(ctx, origin, scale,
        { x: 0, y: centerY, z: 0 },
        endpoint,
        r.toFixed(2) + " " + shape.unit);
      
    }
    // --- Drawing the Scene ---
    function drawScene() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const origin = { x: canvas.width / 2, y: canvas.height / 2 + 100 };
      const scale = 20;
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      shapes.forEach(shape => {
        switch(shape.type) {
          case 'cone': drawCone(shape, ctx, origin, scale); break;
          case 'cylinder': drawCylinder(shape, ctx, origin, scale); break;
          case 'pyramid': drawPyramid(shape, ctx, origin, scale); break;
          case 'prism': drawPrism(shape, ctx, origin, scale); break;
          case 'sphere': drawSphere(shape, ctx, origin, scale); break;
        }
      });
    }

  
    drawScene();
    updateShapeList();

   
    function updateShapeList() {
      let html = "<h3>Stacked Shapes</h3>";
      shapes.forEach((shape, index) => {
        html += `<div class="shape-item">
            <span class="delete-btn" onclick="deleteShape(${index})">[x]</span>
            <strong>${index+1}. ${shape.type.toUpperCase()}</strong><br>
            Unit: ${shape.unit}<br>`;
        for (let key in shape.params) {
          html += `${key}: ${shape.params[key]}<br>`;
        }
        html += `Bottom: ${shape.bottom.toFixed(2)} ${shape.unit}, Top: ${shape.top.toFixed(2)} ${shape.unit}<br>
            Lateral Area: ${shape.computed.lateralArea.toFixed(2)} ${shape.unit}²<br>
            Total Area: ${shape.computed.totalArea.toFixed(2)} ${shape.unit}²<br>
            Volume: ${shape.computed.volume.toFixed(2)} ${shape.unit}³<br>
            <div class="shape-controls">
              <button onclick="moveShape(${index}, 'down')">Down</button>
              <button onclick="moveShape(${index}, 'up')">Up</button>
              <button onclick="editShape(${index})">Edit</button>
            </div>
          </div>`;
      });
      shapeListDiv.innerHTML = html;
    }

  });
</script>
</body>
</html>
