<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Shape Stacker – Pyramid with Base & Lateral Dimensions</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #controls {
      width: 320px;
      padding: 10px;
      background: #f0f0f0;
      overflow-y: auto;
      box-sizing: border-box;
    }
    #canvasContainer {
      flex-grow: 1;
      background: #ddd;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    input, select, button {
      width: 100%;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
    label { font-weight: bold; }
    .shape-list { margin-top: 20px; }
    .shape-item {
      border-bottom: 1px solid #ccc;
      padding: 5px 0;
      font-size: 0.9em;
      position: relative;
    }
    .shape-controls {
      margin-top: 5px;
    }
    .shape-controls button {
      font-size: 0.8em;
      margin-right: 5px;
    }
    .delete-btn {
      position: absolute;
      right: 5px;
      top: 5px;
      color: red;
      cursor: pointer;
      font-weight: bold;
    }
    hr { margin: 10px 0; }
  </style>
</head>
<body>
  <div id="controls">
    <h2>Add Shape</h2>
    <label for="shapeType">Shape Type:</label>
    <select id="shapeType">
      <option value="cone">Cone</option>
      <option value="cylinder">Cylinder</option>
      <option value="pyramid">Pyramid</option>
      <option value="prism">Prism</option>
      <option value="sphere">Sphere</option>
    </select>
    <div id="shapeParams">
      <!-- Parameter inputs inserted dynamically -->
    </div>
    <button id="addShapeBtn">Add Shape</button>
    <hr>
    <div>
      <label for="unit">Measurement Unit:</label>
      <input type="text" id="unit" value="u">
    </div>
    <div class="shape-list" id="shapeList">
      <h3>Stacked Shapes</h3>
      <!-- List of shapes with parameters and controls -->
    </div>
  </div>
  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const shapeTypeSelect = document.getElementById('shapeType');
      const shapeParamsDiv = document.getElementById('shapeParams');
      const addShapeBtn = document.getElementById('addShapeBtn');
      const shapeListDiv = document.getElementById('shapeList');
      const unitInput = document.getElementById('unit');

      let shapes = [];
      let editingIndex = -1;

      // --- Resize Canvas ---
      function resizeCanvas() {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
        drawScene();
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Global drawing settings.
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.lineWidth = 2;

      // --- Dynamic Parameter Panel (unchanged from previous iterations) ---
      function updateShapeParams() {
        const type = shapeTypeSelect.value;
        if (type === 'cone' || type === 'cylinder') {
          shapeParamsDiv.innerHTML = `
            <label for="param_radius">Radius:</label>
            <input type="number" step="any" id="param_radius" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        } else if (type === 'pyramid') {
          shapeParamsDiv.innerHTML = `
            <label for="param_baseType">Base Type:</label>
            <select id="param_baseType">
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="n-gon">N‑gon</option>
            </select>
            <div id="pyramidParams"></div>
          `;
          document.getElementById('param_baseType').addEventListener('change', updatePyramidParams);
          updatePyramidParams();
        } else if (type === 'prism') {
          shapeParamsDiv.innerHTML = `
            <label for="param_baseType">Base Type:</label>
            <select id="param_baseType">
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="n-gon">N‑gon</option>
              <option value="trapeze">Trapeze</option>
            </select>
            <div id="prismParams"></div>
          `;
          document.getElementById('param_baseType').addEventListener('change', updatePrismParams);
          updatePrismParams();
        } else if (type === 'sphere') {
          shapeParamsDiv.innerHTML = `
            <label for="param_radius">Radius:</label>
            <input type="number" step="any" id="param_radius" required>
          `;
        }
      }
      function updatePyramidParams() {
        const baseType = document.getElementById('param_baseType').value;
        const container = document.getElementById('pyramidParams');
        if (baseType === 'square' || baseType === 'triangle') {
          container.innerHTML = `
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        } else if (baseType === 'rectangle') {
          container.innerHTML = `
            <label for="param_width">Width:</label>
            <input type="number" step="any" id="param_width" required>
            <label for="param_depth">Depth:</label>
            <input type="number" step="any" id="param_depth" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        } else if (baseType === 'n-gon') {
          container.innerHTML = `
            <label for="param_n">Number of Sides (n):</label>
            <input type="number" step="1" id="param_n" required>
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        }
      }
      function updatePrismParams() {
        const baseType = document.getElementById('param_baseType').value;
        const container = document.getElementById('prismParams');
        if (baseType === 'square' || baseType === 'triangle') {
          container.innerHTML = `
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        } else if (baseType === 'rectangle') {
          container.innerHTML = `
            <label for="param_width">Width:</label>
            <input type="number" step="any" id="param_width" required>
            <label for="param_depth">Depth:</label>
            <input type="number" step="any" id="param_depth" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        } else if (baseType === 'n-gon') {
          container.innerHTML = `
            <label for="param_n">Number of Sides (n):</label>
            <input type="number" step="1" id="param_n" required>
            <label for="param_side">Side:</label>
            <input type="number" step="any" id="param_side" required>
            <label for="param_height">Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        } else if (baseType === 'trapeze') {
          container.innerHTML = `
            <label for="param_base1">Base 1 (top):</label>
            <input type="number" step="any" id="param_base1" required>
            <label for="param_base2">Base 2 (bottom):</label>
            <input type="number" step="any" id="param_base2" required>
            <label for="param_trapezeHeight">Trapeze Height:</label>
            <input type="number" step="any" id="param_trapezeHeight" required>
            <label for="param_height">Prism Height:</label>
            <input type="number" step="any" id="param_height" required>
          `;
        }
      }
      shapeTypeSelect.addEventListener('change', updateShapeParams);
      updateShapeParams();

      // --- Add or Update Shape (unchanged) ---
      addShapeBtn.addEventListener('click', addOrUpdateShape);
      function addOrUpdateShape() {
        const type = shapeTypeSelect.value;
        const unit = unitInput.value || "u";
        let params = {};
        if (type === 'cone' || type === 'cylinder') {
          params.radius = document.getElementById('param_radius').value;
          params.height = document.getElementById('param_height').value;
        } else if (type === 'pyramid') {
          params.baseType = document.getElementById('param_baseType').value;
          if (params.baseType === 'square' || params.baseType === 'triangle') {
            params.side = document.getElementById('param_side').value;
            params.height = document.getElementById('param_height').value;
          } else if (params.baseType === 'rectangle') {
            params.width = document.getElementById('param_width').value;
            params.depth = document.getElementById('param_depth').value;
            params.height = document.getElementById('param_height').value;
          } else if (params.baseType === 'n-gon') {
            params.n = document.getElementById('param_n').value;
            params.side = document.getElementById('param_side').value;
            params.height = document.getElementById('param_height').value;
          }
        } else if (type === 'prism') {
          params.baseType = document.getElementById('param_baseType').value;
          if (params.baseType === 'square' || params.baseType === 'triangle') {
            params.side = document.getElementById('param_side').value;
            params.height = document.getElementById('param_height').value;
          } else if (params.baseType === 'rectangle') {
            params.width = document.getElementById('param_width').value;
            params.depth = document.getElementById('param_depth').value;
            params.height = document.getElementById('param_height').value;
          } else if (params.baseType === 'n-gon') {
            params.n = document.getElementById('param_n').value;
            params.side = document.getElementById('param_side').value;
            params.height = document.getElementById('param_height').value;
          } else if (params.baseType === 'trapeze') {
            params.base1 = document.getElementById('param_base1').value;
            params.base2 = document.getElementById('param_base2').value;
            params.trapezeHeight = document.getElementById('param_trapezeHeight').value;
            params.height = document.getElementById('param_height').value;
          }
        } else if (type === 'sphere') {
          params.radius = document.getElementById('param_radius').value;
          params.height = 2 * parseFloat(params.radius);
        }
        if (editingIndex === -1) {
          shapes.push({ type, params, unit });
          computeShapeProperties(shapes[shapes.length - 1]);
        } else {
          shapes[editingIndex] = { type, params, unit };
          computeShapeProperties(shapes[editingIndex]);
          editingIndex = -1;
          addShapeBtn.textContent = "Add Shape";
        }
        updateStackElevations();
        updateShapeList();
        drawScene();
      }

      // --- Delete, Move, and Edit Controls (unchanged) ---
      window.deleteShape = function(index) {
        shapes.splice(index, 1);
        updateStackElevations();
        updateShapeList();
        drawScene();
      };
      window.moveShape = function(index, direction) {
        if (direction === 'up' && index < shapes.length - 1) {
          [shapes[index], shapes[index + 1]] = [shapes[index + 1], shapes[index]];
        } else if (direction === 'down' && index > 0) {
          [shapes[index], shapes[index - 1]] = [shapes[index - 1], shapes[index]];
        }
        updateStackElevations();
        updateShapeList();
        drawScene();
      };
      window.editShape = function(index) {
        const shape = shapes[index];
        shapeTypeSelect.value = shape.type;
        updateShapeParams();
        if (shape.type === 'cone' || shape.type === 'cylinder') {
          document.getElementById('param_radius').value = shape.params.radius;
          document.getElementById('param_height').value = shape.params.height;
        } else if (shape.type === 'pyramid') {
          document.getElementById('param_baseType').value = shape.params.baseType;
          updatePyramidParams();
          if (shape.params.baseType === 'square' || shape.params.baseType === 'triangle') {
            document.getElementById('param_side').value = shape.params.side;
            document.getElementById('param_height').value = shape.params.height;
          } else if (shape.params.baseType === 'rectangle') {
            document.getElementById('param_width').value = shape.params.width;
            document.getElementById('param_depth').value = shape.params.depth;
            document.getElementById('param_height').value = shape.params.height;
          } else if (shape.params.baseType === 'n-gon') {
            document.getElementById('param_n').value = shape.params.n;
            document.getElementById('param_side').value = shape.params.side;
            document.getElementById('param_height').value = shape.params.height;
          }
        } else if (shape.type === 'prism') {
          document.getElementById('param_baseType').value = shape.params.baseType;
          updatePrismParams();
          if (shape.params.baseType === 'square' || shape.params.baseType === 'triangle') {
            document.getElementById('param_side').value = shape.params.side;
            document.getElementById('param_height').value = shape.params.height;
          } else if (shape.params.baseType === 'rectangle') {
            document.getElementById('param_width').value = shape.params.width;
            document.getElementById('param_depth').value = shape.params.depth;
            document.getElementById('param_height').value = shape.params.height;
          } else if (shape.params.baseType === 'n-gon') {
            document.getElementById('param_n').value = shape.params.n;
            document.getElementById('param_side').value = shape.params.side;
            document.getElementById('param_height').value = shape.params.height;
          } else if (shape.params.baseType === 'trapeze') {
            document.getElementById('param_base1').value = shape.params.base1;
            document.getElementById('param_base2').value = shape.params.base2;
            document.getElementById('param_trapezeHeight').value = shape.params.trapezeHeight;
            document.getElementById('param_height').value = shape.params.height;
          }
        } else if (shape.type === 'sphere') {
          document.getElementById('param_radius').value = shape.params.radius;
        }
        unitInput.value = shape.unit;
        addShapeBtn.textContent = "Update Shape";
        editingIndex = index;
      };

      // --- Update Stacking Elevations ---
      function updateStackElevations() {
        let currentElevation = 0;
        shapes.forEach(shape => {
          shape.bottom = currentElevation;
          let h = parseFloat(shape.params.height);
          shape.top = shape.bottom + h;
          currentElevation = shape.top;
        });
      }

      // --- Compute Shape Properties (unchanged) ---
      function computeShapeProperties(shape) {
        let computed = {};
        if (shape.type === 'cone') {
          const r = parseFloat(shape.params.radius);
          const h = parseFloat(shape.params.height);
          const s = Math.sqrt(r*r + h*h);
          computed.lateralArea = Math.PI * r * s;
          computed.totalArea = Math.PI * r * (r + s);
          computed.volume = (1/3) * Math.PI * r*r * h;
        } else if (shape.type === 'cylinder') {
          const r = parseFloat(shape.params.radius);
          const h = parseFloat(shape.params.height);
          computed.lateralArea = 2 * Math.PI * r * h;
          computed.totalArea = 2 * Math.PI * r * (r + h);
          computed.volume = Math.PI * r*r * h;
        } else if (shape.type === 'pyramid') {
          const baseType = shape.params.baseType;
          const h = parseFloat(shape.params.height);
          if (baseType === 'square') {
            const a = parseFloat(shape.params.side);
            const baseArea = a * a;
            const s = Math.sqrt((a/2)**2 + h*h);
            computed.lateralArea = 2 * a * s;
            computed.totalArea = baseArea + computed.lateralArea;
            computed.volume = (1/3) * baseArea * h;
          } else if (baseType === 'rectangle') {
            const w = parseFloat(shape.params.width);
            const d = parseFloat(shape.params.depth);
            const baseArea = w * d;
            const s1 = Math.sqrt((d/2)**2 + h*h);
            const s2 = Math.sqrt((w/2)**2 + h*h);
            computed.lateralArea = w * s1 + d * s2;
            computed.totalArea = baseArea + computed.lateralArea;
            computed.volume = (1/3) * baseArea * h;
          } else if (baseType === 'triangle') {
            const a = parseFloat(shape.params.side);
            const baseArea = (Math.sqrt(3)/4) * a * a;
            const s = Math.sqrt(h*h + (a/Math.sqrt(3))**2);
            computed.lateralArea = (3 * a * s)/2;
            computed.totalArea = baseArea + computed.lateralArea;
            computed.volume = (1/3) * baseArea * h;
          } else if (baseType === 'n-gon') {
            const n = parseInt(shape.params.n);
            const a = parseFloat(shape.params.side);
            const baseArea = (n * a * a)/(4 * Math.tan(Math.PI/n));
            const R = a/(2 * Math.sin(Math.PI/n));
            const s = Math.sqrt(h*h + R*R);
            computed.lateralArea = 0.5 * n * a * s;
            computed.totalArea = baseArea + computed.lateralArea;
            computed.volume = (1/3) * baseArea * h;
          }
        } else if (shape.type === 'prism') {
          const baseType = shape.params.baseType;
          const h = parseFloat(shape.params.height);
          if (baseType === 'square') {
            const a = parseFloat(shape.params.side);
            const baseArea = a * a;
            computed.lateralArea = 4 * a * h;
            computed.totalArea = 2 * baseArea + computed.lateralArea;
            computed.volume = baseArea * h;
          } else if (baseType === 'rectangle') {
            const w = parseFloat(shape.params.width);
            const d = parseFloat(shape.params.depth);
            const baseArea = w * d;
            computed.lateralArea = 2 * (w + d) * h;
            computed.totalArea = 2 * baseArea + computed.lateralArea;
            computed.volume = baseArea * h;
          } else if (baseType === 'triangle') {
            const a = parseFloat(shape.params.side);
            const baseArea = (Math.sqrt(3)/4) * a * a;
            computed.lateralArea = 3 * a * h;
            computed.totalArea = 2 * baseArea + computed.lateralArea;
            computed.volume = baseArea * h;
          } else if (baseType === 'n-gon') {
            const n = parseInt(shape.params.n);
            const a = parseFloat(shape.params.side);
            const baseArea = (n * a * a)/(4 * Math.tan(Math.PI/n));
            computed.lateralArea = n * a * h;
            computed.totalArea = 2 * baseArea + computed.lateralArea;
            computed.volume = baseArea * h;
          } else if (baseType === 'trapeze') {
            const b1 = parseFloat(shape.params.base1);
            const b2 = parseFloat(shape.params.base2);
            const tH = parseFloat(shape.params.trapezeHeight);
            const baseArea = ((b1 + b2)/2) * tH;
            const side = Math.sqrt(((b2-b1)/2)**2 + tH*tH);
            computed.lateralArea = (b1 + b2 + 2*side) * h;
            computed.totalArea = 2 * baseArea + computed.lateralArea;
            computed.volume = baseArea * h;
          }
        } else if (shape.type === 'sphere') {
          const r = parseFloat(shape.params.radius);
          computed.totalArea = 4 * Math.PI * r * r;
          computed.lateralArea = computed.totalArea;
          computed.volume = (4/3) * Math.PI * r * r * r;
        }
        shape.computed = computed;
      }

      // --- Helper: 2D Cross Product (for convex hull) ---
      function cross(o, a, b) {
        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
      }

      // --- Compute Convex Hull (Andrew's Monotone Chain) ---
      function computeConvexHull(points) {
        let pts = points.slice();
        pts.sort((a, b) => {
          if (a.proj.x === b.proj.x) return a.proj.y - b.proj.y;
          return a.proj.x - b.proj.x;
        });
        const lower = [];
        for (let p of pts) {
          while (lower.length >= 2 && cross(lower[lower.length - 2].proj, lower[lower.length - 1].proj, p.proj) <= 0) {
            lower.pop();
          }
          lower.push(p);
        }
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
          let p = pts[i];
          while (upper.length >= 2 && cross(upper[upper.length - 2].proj, upper[upper.length - 1].proj, p.proj) <= 0) {
            upper.pop();
          }
          upper.push(p);
        }
        lower.pop();
        upper.pop();
        return lower.concat(upper);
      }

      // --- Draw Silhouette (convex hull) ---
      function drawSilhouette(samplePoints, ctx, origin, scale) {
        const hull = computeConvexHull(samplePoints);
        ctx.beginPath();
        for (let i = 0; i < hull.length; i++) {
          let pt = hull[i];
          let X = origin.x + pt.proj.x * scale;
          let Y = origin.y + pt.proj.y * scale;
          if (i === 0) ctx.moveTo(X, Y);
          else ctx.lineTo(X, Y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // --- Isometric Projection ---
      function project(x, y, z) {
        const angle = Math.PI / 6; // 30°
        const isoX = (x - z) * Math.cos(angle);
        const isoY = y + (x + z) * Math.sin(angle);
        return { x: isoX, y: -isoY };
      }

      // --- Draw Dimension Line ---
      function drawDimensionLine(ctx, origin, scale, point1, point2, text) {
        const p1 = project(point1.x, point1.y, point1.z);
        const p2 = project(point2.x, point2.y, point2.z);
        const x1 = origin.x + p1.x * scale;
        const y1 = origin.y + p1.y * scale;
        const x2 = origin.x + p2.x * scale;
        const y2 = origin.y + p2.y * scale;
        ctx.save();
        ctx.lineWidth = 2;
        ctx.setLineDash([10,10]);
        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = 'blue';
        ctx.font = "12px sans-serif";
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        ctx.fillText(text, midX + 5, midY - 5);
        ctx.restore();
      }

      // --- Helper: Draw Polygon in Dotted Lines ---
      function drawPolygonDotted(points, origin, scale) {
        ctx.setLineDash([10,10]);
        ctx.beginPath();
        for (let i = 0; i < points.length; i++) {
          let p = project(points[i].x, points[i].y, points[i].z);
          let X = origin.x + p.x * scale;
          let Y = origin.y + p.y * scale;
          if (i === 0) ctx.moveTo(X, Y);
          else ctx.lineTo(X, Y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // --- Helper: Compute Midpoint Between Two Points ---
      function computeMidpoint(pt1, pt2) {
        return { x: (pt1.x+pt2.x)/2, y: pt1.y, z: (pt1.z+pt2.z)/2 };
      }

      // --- Draw Pyramid ---
      // This routine draws:
      //   1. The lateral silhouette (base plus apex) as before.
      //   2. The full base outline as a dotted polygon.
      //   3. For n‑gon pyramids (but not square), the base apothem (from base center to midpoint of an edge) is drawn.
      //   4. For all pyramids, the slant height (lateral face apothem) is drawn from the midpoint of the front edge to the apex.
      //   5. The side length for the left edge is labeled.
      function drawPyramid(shape, ctx, origin, scale) {
        const bottomY = shape.bottom;
        const topY = shape.top;
        const baseType = shape.params.baseType;
        let basePoints = [];
        if (baseType === 'square') {
          const a = parseFloat(shape.params.side);
          basePoints = [
            { x: -a/2, y: bottomY, z: -a/2 },
            { x: a/2, y: bottomY, z: -a/2 },
            { x: a/2, y: bottomY, z: a/2 },
            { x: -a/2, y: bottomY, z: a/2 }
          ];
        } else if (baseType === 'rectangle') {
          const w = parseFloat(shape.params.width);
          const d = parseFloat(shape.params.depth);
          basePoints = [
            { x: -w/2, y: bottomY, z: -d/2 },
            { x: w/2, y: bottomY, z: -d/2 },
            { x: w/2, y: bottomY, z: d/2 },
            { x: -w/2, y: bottomY, z: d/2 }
          ];
        } else if (baseType === 'triangle') {
          const a = parseFloat(shape.params.side);
          for (let i = 0; i < 3; i++) {
            let angle = -Math.PI/2 + i*(2*Math.PI/3);
            basePoints.push({ x: a*Math.cos(angle), y: bottomY, z: a*Math.sin(angle) });
          }
        } else if (baseType === 'n-gon') {
          const n = parseInt(shape.params.n);
          const a = parseFloat(shape.params.side);
          const R = a/(2*Math.sin(Math.PI/n));
          for (let i = 0; i < n; i++) {
            let angle = -Math.PI/2 + i*(2*Math.PI/n);
            basePoints.push({ x: R*Math.cos(angle), y: bottomY, z: R*Math.sin(angle) });
          }
        }

        // Draw the lateral silhouette (base + apex) as before.
        let samplePoints = [];
        basePoints.forEach(pt => {
          samplePoints.push({ world: pt, proj: project(pt.x, pt.y, pt.z) });
        });
        samplePoints.push({ world: { x: 0, y: topY, z: 0 }, proj: project(0, topY, 0) });
        drawSilhouette(samplePoints, ctx, origin, scale);

        // Draw the full base outline in dotted lines.
        drawPolygonDotted(basePoints, origin, scale);

        // For regular polygons, the base is centered at (0,bottomY,0)
        const baseCenter = { x: 0, y: bottomY, z: 0 };

        // If the base is an n-gon (and not a square), display the base apothem.
        if (baseType === 'n-gon') {
          // For a regular n-gon, all base apothems are equal.
          let midEdge = computeMidpoint(basePoints[0], basePoints[1]);
          let baseApothem = Math.sqrt(midEdge.x*midEdge.x + midEdge.z*midEdge.z);
          drawDimensionLine(ctx, origin, scale, baseCenter, midEdge, "a: " + baseApothem.toFixed(2) + " " + shape.unit);
        }

        // Compute the "front" edge as the one whose midpoint has the smallest world z (most toward viewer).
        let frontEdge = null;
        basePoints.forEach((pt, i) => {
          let next = basePoints[(i+1)%basePoints.length];
          let mid = computeMidpoint(pt, next);
          if (!frontEdge || mid.z < frontEdge.mid.z) {
            frontEdge = { mid: mid, pt1: pt, pt2: next };
          }
        });
        // The slant height is the lateral face apothem: the distance from the midpoint of the front edge to the apex.
        let horizontal = Math.sqrt(frontEdge.mid.x*frontEdge.mid.x + frontEdge.mid.z*frontEdge.mid.z);
        let slant = Math.sqrt(horizontal*horizontal + (topY - bottomY)**2);
        drawDimensionLine(ctx, origin, scale, frontEdge.mid, { x: 0, y: topY, z: 0 }, "l: " + slant.toFixed(2) + " " + shape.unit);

        // Compute the "left" edge as the one whose midpoint has the smallest world x (most negative).
        let leftEdge = null;
        basePoints.forEach((pt, i) => {
          let next = basePoints[(i+1)%basePoints.length];
          let mid = computeMidpoint(pt, next);
          if (!leftEdge || mid.x < leftEdge.mid.x) {
            leftEdge = { mid: mid, pt1: pt, pt2: next };
          }
        });
        let sideLength = Math.sqrt((leftEdge.pt1.x - leftEdge.pt2.x)**2 + (leftEdge.pt1.z - leftEdge.pt2.z)**2);
        drawDimensionLine(ctx, origin, scale, leftEdge.pt1, leftEdge.pt2, "s: " + sideLength.toFixed(2) + " " + shape.unit);

        // Draw vertical dimension from base to apex.
        drawDimensionLine(ctx, origin, scale, baseCenter, { x: 0, y: topY, z: 0 }, Math.abs(topY - bottomY).toFixed(2) + " " + shape.unit);
      }

      // --- Draw Prism (unchanged) ---
      function drawPrism(shape, ctx, origin, scale) {
        const bottomY = shape.bottom;
        const topY = shape.top;
        const baseType = shape.params.baseType;
        let bottomPoints = [];
        if (baseType === 'square') {
          const a = parseFloat(shape.params.side);
          bottomPoints = [
            { x: -a/2, y: bottomY, z: -a/2 },
            { x: a/2, y: bottomY, z: -a/2 },
            { x: a/2, y: bottomY, z: a/2 },
            { x: -a/2, y: bottomY, z: a/2 }
          ];
        } else if (baseType === 'rectangle') {
          const w = parseFloat(shape.params.width);
          const d = parseFloat(shape.params.depth);
          bottomPoints = [
            { x: -w/2, y: bottomY, z: -d/2 },
            { x: w/2, y: bottomY, z: -d/2 },
            { x: w/2, y: bottomY, z: d/2 },
            { x: -w/2, y: bottomY, z: d/2 }
          ];
        } else if (baseType === 'triangle') {
          const a = parseFloat(shape.params.side);
          for (let i = 0; i < 3; i++) {
            let angle = -Math.PI/2 + i*(2*Math.PI/3);
            bottomPoints.push({ x: a*Math.cos(angle), y: bottomY, z: a*Math.sin(angle) });
          }
        } else if (baseType === 'n-gon') {
          const n = parseInt(shape.params.n);
          const a = parseFloat(shape.params.side);
          const R = a/(2*Math.sin(Math.PI/n));
          for (let i = 0; i < n; i++) {
            let angle = -Math.PI/2 + i*(2*Math.PI/n);
            bottomPoints.push({ x: R*Math.cos(angle), y: bottomY, z: R*Math.sin(angle) });
          }
        } else if (baseType === 'trapeze') {
          const b1 = parseFloat(shape.params.base1);
          const b2 = parseFloat(shape.params.base2);
          const tH = parseFloat(shape.params.trapezeHeight);
          bottomPoints = [
            { x: -b2/2, y: bottomY, z: -tH/2 },
            { x: b2/2, y: bottomY, z: -tH/2 },
            { x: b1/2, y: bottomY, z: tH/2 },
            { x: -b1/2, y: bottomY, z: tH/2 }
          ];
        }
        let samplePoints = [];
        bottomPoints.forEach(pt => {
          samplePoints.push({ world: pt, proj: project(pt.x, pt.y, pt.z) });
          samplePoints.push({ world: { x: pt.x, y: topY, z: pt.z }, proj: project(pt.x, topY, pt.z) });
        });
        drawSilhouette(samplePoints, ctx, origin, scale);
        drawDimensionLine(ctx, origin, scale,
          { x: 0, y: bottomY, z: 0 },
          { x: 0, y: topY, z: 0 },
          Math.abs(topY - bottomY).toFixed(2) + " " + shape.unit);
      }

      function drawSphere(shape, ctx, origin, scale) {
        const r = parseFloat(shape.params.radius);
        const bottomY = shape.bottom;
        const topY = shape.top;
        const centerY = bottomY + r;
        const centerP = project(0, centerY, 0);
        const cx = origin.x + centerP.x * scale;
        const cy = origin.y + centerP.y * scale;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, r*scale, 0, 2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(cx, cy, r*scale, r*scale*0.5, 0, 0, 2*Math.PI);
        ctx.stroke();
        drawDimensionLine(ctx, origin, scale,
          { x: 0, y: centerY, z: 0 },
          { x: r, y: centerY, z: 0 },
          r.toFixed(2) + " " + shape.unit);
        drawDimensionLine(ctx, origin, scale,
          { x: 0, y: bottomY, z: 0 },
          { x: 0, y: topY, z: 0 },
          (2*r).toFixed(2) + " " + shape.unit);
      }

      // --- Drawing the Scene ---
      function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const origin = { x: canvas.width/2, y: canvas.height/2+100 };
        const scale = 20;
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        shapes.forEach(shape => {
          switch(shape.type) {
            case 'cone': drawCone(shape, ctx, origin, scale); break;
            case 'cylinder': drawCylinder(shape, ctx, origin, scale); break;
            case 'pyramid': drawPyramid(shape, ctx, origin, scale); break;
            case 'prism': drawPrism(shape, ctx, origin, scale); break;
            case 'sphere': drawSphere(shape, ctx, origin, scale); break;
          }
        });
      }

      // Initial draw and update list.
      drawScene();
      updateShapeList();

      // --- Update Shape List Display ---
      function updateShapeList() {
        let html = "<h3>Stacked Shapes</h3>";
        shapes.forEach((shape, index) => {
          html += `<div class="shape-item">
            <span class="delete-btn" onclick="deleteShape(${index})">[x]</span>
            <strong>${index+1}. ${shape.type.toUpperCase()}</strong><br>
            Unit: ${shape.unit}<br>`;
          for (let key in shape.params) {
            html += `${key}: ${shape.params[key]}<br>`;
          }
          html += `Bottom: ${shape.bottom.toFixed(2)} ${shape.unit}, Top: ${shape.top.toFixed(2)} ${shape.unit}<br>
            Lateral Area: ${shape.computed.lateralArea.toFixed(2)} ${shape.unit}²<br>
            Total Area: ${shape.computed.totalArea.toFixed(2)} ${shape.unit}²<br>
            Volume: ${shape.computed.volume.toFixed(2)} ${shape.unit}³<br>
            <div class="shape-controls">
              <button onclick="moveShape(${index}, 'down')">Down</button>
              <button onclick="moveShape(${index}, 'up')">Up</button>
              <button onclick="editShape(${index})">Edit</button>
            </div>
          </div>`;
        });
        shapeListDiv.innerHTML = html;
      }
    });
  </script>
</body>
</html>
